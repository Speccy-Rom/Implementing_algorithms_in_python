# Алгоритмы сортировок. 

## Алгоритм сортировки выбором
### Содержание:

Алгоритм сортировки выбором заключается в поиске на необработанном срезе массива или списка минимального значения и в дальнейшем обмене этого значения с первым элементом необработанного среза. На следующем шаге необработанный срез уменьшается на один элемент.

Найти наименьшее значение в списке.
Записать его в начало списка, а первый элемент - на место, где раньше стоял наименьший.
Снова найти наименьший элемент в списке. При этом в поиске не участвует первый элемент.
Второй минимум поместить на второе место списка. Второй элемент при этом перемещается на освободившееся место.
Продолжать выполнять поиcк и обмен, пока не будет достигнут конец списка.

## Алгоритм сортировки вставками
### Содержание:
Сортировка вставками (insertion sort) - это алгоритм сортировка, в котором все элементы массива просматриваются поочередно, при этом каждый элемент размещается в соответственное место среди ранее упорядоченных значений.

Общая суть сортировок вставками такова:

Перебираются элементы в неотсортированной части массива.
Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.

Сортировки вставками всегда делят массив на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается любой элемент. Поскольку другая часть массива отсортирована, то в ней достаточно быстро можно найти своё место для этого извлечённого элемента. Элемент вставляется куда нужно, в результате чего отсортированная часть массива увеличивается, а неотсортированная уменьшается. Всё. По такому принципу работают все сортировки вставками.

Самое слабое место в этом подходе — вставка элемента в отсортированную часть массива. На самом деле это непросто и на какие только ухищрения не приходится идти, чтобы выполнить этот шаг.

## Алгоритм сортировка пузырьком (метод всплывающего пузырька) 
### Содержание:

Сортировка пузырьком - это метод сортировки массивов и списков путем последовательного сравнения и обмена соседних элементов, если предшествующий оказывается больше последующего.

Алгоритм и особенности этой сортировки таковы:
При первом проходе по массиву элементы попарно сравниваются между собой: первый со вторым, затем второй с третьим, следом третий с четвертым и т.д. Если предшествующий элемент оказывается больше последующего, то их меняют местами.
Не трудно догадаться, что постепенно самое большое число оказывается последним. Остальная часть массива остается не отсортированной, хотя некоторое перемещение элементов с меньшим значением в начало массива наблюдается.
При втором проходе незачем сравнивать последний элемент с предпоследним. Последний элемент уже стоит на своем месте. Значит, число сравнений будет на одно меньше.
На третьем проходе уже не надо сравнивать предпоследний и третий элемент с конца. Поэтому число сравнений будет на два меньше, чем при первом проходе.
В конце концов, при проходе по массиву, когда остаются только два элемента, которые надо сравнить, выполняется только одно сравнение.
После этого первый элемент не с чем сравнивать, и, следовательно, последний проход по массиву не нужен. Другими словами, количество проходов по массиву равно m-1, где m – это количество элементов массива.
Количество сравнений в каждом проходе равно m-i, где i – это номер прохода по массиву (первый, второй, третий и т.д.).
При обмене элементов массива обычно используется "буферная" (третья) переменная, куда временно помещается значение одного из элементов.

## Алгоритм слияния двух упорядоченных списков
### Содержание:
Рассматривается эффективный алгоритм слияния двух упорядоченных списков в третий, так, чтобы результирующий список тоже был упорядоченным. Приведена реализация этого алгоритма на языке Python.
Суть сортировки
Сортируемый массив разбивается на две части примерно одинакового размера.
Каждая из получившихся частей сортируется отдельно, например, тем же самым алгоритмом.
Два упорядоченных массива половинного размера соединяются в один.
Сложность сортировки по времени
Худшая O(n log n)
Средняя O(n log n)
Лучшая O(n log n)
Шаги к правильному решению
Создадим функцию merge_sort, которая принимает на вход список и 2 переменные: start и end.
Функция merge_sort будет сортировать список от start до end-1 индексов.
Если end-start не больше 1, выходим.
Иначе, устанавливаем mid = (start+end)//2 (округляет до меньшего 15//2=7)
Вызываем merge_sort(alist, start, mid).
Вызываем merge_sort(alist, mid, end).
Вызываем merge_list(alist, start, mid, end).
Функция принимает список и 3 параметра, полагает, что список отсортирован от start до mid-1 и от mid до end-1, смерживает их и образует новый сортированный список от start до en

## Алгоритм сортировки слиянием (merge sort) 
### Содержание:
Сортировка слиянием (Merge Sort) — один из самых известных алгоритмов сортировки. Если вы изучаете информатику, Merge Sort вместе с Quick Sort, вероятно, является первым эффективным алгоритмом сортировки общего назначения, о котором вы слышали. Также классический пример алгоритма «разделяй и властвуй» (divide-and-conquer).

Суть сортировки
Сортируемый массив разбивается на две части примерно одинакового размера.
Каждая из получившихся частей сортируется отдельно, например, тем же самым алгоритмом.
Два упорядоченных массива половинного размера соединяются в один.
Сложность сортировки по времени
Худшая O(n log n)
Средняя O(n log n)
Лучшая O(n log n)
Шаги к правильному решению
Создадим функцию merge_sort, которая принимает на вход список и 2 переменные: start и end.
Функция merge_sort будет сортировать список от start до end-1 индексов.
Если end-start не больше 1, выходим.
Иначе, устанавливаем mid = (start+end)//2 (округляет до меньшего 15//2=7)
Вызываем merge_sort(alist, start, mid).
Вызываем merge_sort(alist, mid, end).
Вызываем merge_list(alist, start, mid, end).
Функция принимает список и 3 параметра, полагает, что список отсортирован от start до mid-1 и от mid до end-1, смерживает их и образует новый сортированный список от start до end-1.

## Алгоритм быстрой сортировки Хоара через рекурсию
### Содержание:

Этот алгоритм, чаще называемый просто «быстрая сортировка» (англ. Quicksort) придуман английским ученым Чарльзом Хоаром в 1960 году.

Во многом идея быстрой сортировки такая же, как у алгоритма сортировки слиянием. Выберем некоторый элемент q, называемый барьерным элементом. Разобьем массив на две части, переупорядочив его элементы. В первой части соберем элементы, меньшие или равные q, а во второй части — большие или равные q. Теперь достаточно отсортировать обе части, после чего выполнить их конкатенацию безо всякого дополнительного слияния.

Асимптотика алгоритма
Сложность алгоритма быстрой сортировки Хоара зависит от метода выбора барьерного элемента. В лучшем случае при каждом выборе барьерного элемента должен выбираться медианный элемент массива. Но поиск медианного элемента — сложная задача, её нельзя решить быстро. Если выбрать первый элемент фрагмента списка A[l] или последний A[r], то если список A уже упорядочен, сложность алгоритма будет , так как на каждом рекурсивном вызове от большей части списка будет отделяться всего один элемент.

Поэтому в алгоритме быстрой сортировки Хоара, как правило, в качестве барьерного элемента выбирается случайный элемент списка. Тогда алгоритм становится вероятностным — время его работы зависит от того, каким будет случайно выбранный элемент. Возможна (но крайне маловероятна) ситуация, когда всегда будет выбираться наименьший элемент, и в этом случае алгоритм будет работать за .

В теории вероятностей доказывается, чти при случайном выборе элемента списка и разбиении его на две части, размер большей из двух получившихся частей будет в среднем равен . В этом случае глубина рекурсии в среднем будет составлять порядка , а средняя сложность алгоритма быстрой сортировки Хоара — .